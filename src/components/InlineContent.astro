---
import type { YAMLBlock } from "@types";
export interface Props {
  id?: string;
  classList?: string;
  block: YAMLBlock;
}

const { id, classList, block } = Astro.props;

// Serialize block data for use in the web component
const blockData = JSON.stringify(block);
---

<inline-mixed-content
  data-block={blockData}
  data-classlist={classList}
  data-id={id}
>
</inline-mixed-content>

<script>
  import type { HTMLObject, HTMLObjectBlock, MixedBlock, ContentTag } from "@types";
  import {
    isMixedBlock,
    transformMixedBlockToHTMLObject,
    isContentTagCollection
  } from "@lib/utils";
import { isHTMLObjectBlock } from "@lib/utils";
  // Utility function for rendering HTMLObject or MixedBlock
  export function parseMixedContent2(
    block: MixedBlock | HTMLObjectBlock | HTMLObjectBlock[] | ContentTag[]
  ): string {
    // Add a function to handle MixedBlock specifically
    if (isContentTagCollection(block)) {
    return block
      .map((tag: ContentTag) => {
        const attributes = typeof tag === "object" ? Object.values(tag)[0] : null;      
        return `
          <${tag.tag} ${tag.class ? `class="${tag.class}"` : ""}
            ${attributes && typeof attributes === "object" && attributes.src ? `src="${attributes.src}"` : ""}
            ${attributes && typeof attributes === "object" && attributes.alt ? `alt="${attributes.alt}"` : ""} >
            ${attributes && typeof attributes === "object" && (attributes.property || attributes.str || "")}
          </${tag.tag}>
          `;
      })
      .join("");
    } else if (isHTMLObjectBlock(block)) {
    // Otherwise handle as HTMLObject - need to test
    return renderHTMLObject(block);
    }
    return "";
  }

  export function renderHTMLObject(data: HTMLObject): string {
    if (!data || !data.tag) return "";
    const children = (data.children || [])
      .map((child) => renderHTMLObject(child))
      .join("");
    const props = Object.entries(data.props || {})
      .map(([key, value]) => `${key}="${value}"`)
      .join(" ");

    return `<${data.tag} ${props}>${data.content || ""}${children}</${data.tag}>`;
  }

  class InlineMixedContent extends HTMLElement {
    constructor() {
      super();

      // Parse dataset attributes
      const block = this.dataset.block ? JSON.parse(this.dataset.block) : {};
      const classList = this.dataset.classlist || "";
      const id = this.dataset.id || "";
      // check if is mixed block or html block
      if (isMixedBlock(block)) {
        const convertedBlock = transformMixedBlockToHTMLObject(block);
        // Render parsed content
        const parsedContent = parseMixedContent2(convertedBlock);
        // Set inner HTML
        this.innerHTML = parsedContent;
      } else {
        console.log(typeof block);
        // Render parsed content
        const parsedContent = Array.isArray(block)
          ? block.map((item) => renderHTMLObject(item)).join("")
          : renderHTMLObject(block);
        console.log(parsedContent);
        // Set inner HTML
        this.innerHTML = parsedContent;
      }
      // Apply classList and ID to the parent block element
      if (classList) this.className += ` ${classList}`;
      if (id) this.id = id;
    }
  }

  // Define the custom element
  window.customElements.define("inline-mixed-content", InlineMixedContent);
</script>
